<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0048)http://hdl.telecom-paristech.fr/sc_exemples.html -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" hola_ext_inject="disabled"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Premiers exemples</title>
  
  <meta http-equiv="Content-Language" content="fr">
  <link rel="stylesheet" type="text/css" href="./Premiers exemples_files/navbar.css">
  <link rel="stylesheet" type="text/css" href="./Premiers exemples_files/navbar_style.css">
  <link rel="stylesheet" type="text/css" href="./Premiers exemples_files/layout_hdl.css">
  <link rel="stylesheet" type="text/css" href="./Premiers exemples_files/style_systemc.css">
  <link rel="stylesheet" type="text/css" href="./Premiers exemples_files/code_commente.css">
  <link rel="stylesheet" type="text/css" href="./Premiers exemples_files/positions_systemc_exemples.css">
  <script src="./Premiers exemples_files/jquery-latest.js"></script><style type="text/css"></style>
  <script type="text/javascript" charset="utf-8">
    $(function(){
       $(".toggle_answer").click(function(event) {  
          event.preventDefault();
          d = $(event.target).parent().children(".answer");
          if (d.is(":visible"))
            $(this).html("Afficher la réponse");
          else
            $(this).html("Masquer la réponse");
    
          d.slideToggle();
    
       });  
    });  
  </script>
</head>
<body cz-shortcut-listen="true">
<div class="logo"><img src="./Premiers exemples_files/logo_enst.png" alt="(c) ENST"></div>
<div id="header">
<h1>Cours en ligne SystemC</h1>
<h2>Exemples</h2>
</div>
<div class="LocalNavBar">
<ul class="NavBar" id="NavBar">
  <li><a href="http://hdl.telecom-paristech.fr/sc_intro.html">Introduction</a>
    <ul>
      <li><a href="http://hdl.telecom-paristech.fr/sc_intro.html#header">Préambule</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_intro.html#apropos">Généralités</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_intro.html#objectifs">Objectifs</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_intro.html#organisation">Organisation</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_intro.html#structure">Structure</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_intro.html#remarques">Remarques</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_intro.html#changelog">Changelog</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_intro.html#enbref">En bref</a></li>
    </ul>
  </li>
  <li class="selected"><a href="http://hdl.telecom-paristech.fr/sc_exemples.html">Exemples pratiques</a>
    <ul>
      <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#header">Préambule</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_and3">AND3</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_dff">DFF</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_dffa">DFFA</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_compteur">Compteur</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_shifter">Shifter</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_ram">RAM</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_simu">Simulation</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#enbref">Résumé</a></li>
    </ul>
  </li>
  <li><a href="http://hdl.telecom-paristech.fr/sc_datatypes.html">Type de données</a>
    <ul>
      <li><a href="http://hdl.telecom-paristech.fr/sc_datatypes.html#header">Préambule</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_datatypes.html#bit">Bits</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_datatypes.html#bv">Bits vecteurs</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_datatypes.html#int">Entiers</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_datatypes.html#fix">Virgule fixe</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_datatypes.html#time">Types temporels</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_datatypes.html#enbref">Résumé</a></li>
    </ul>
  </li>
  <li><a href="http://hdl.telecom-paristech.fr/sc_struct.html">Interface, ports, canaux</a>
    <ul>
      <li><a href="http://hdl.telecom-paristech.fr/sc_struct.html#header">Préambule</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_struct.html#interfaces">Interfaces</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_struct.html#canaux">Canaux</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_struct.html#ports">Ports</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_struct.html#modules">Modules</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_struct.html#enbref">Résumé</a></li>
    </ul>
  </li>
  <li><a href="http://hdl.telecom-paristech.fr/sc_func.html">Processus, événements</a>
    <ul>
      <li><a href="http://hdl.telecom-paristech.fr/sc_func.html#header">Préambule</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_func.html#evts">Événements</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_func.html#processus">Processus</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_func.html#sc_method">SC_METHOD</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_func.html#sc_thread">SC_THREAD</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_func.html#sc_cthread">SC_CTHREAD</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_func.html#enbref">Résumé</a></li>
    </ul>
  </li>
  <li><a href="http://hdl.telecom-paristech.fr/sc_simu.html">Pratique</a>
    <ul>
      <li><a href="http://hdl.telecom-paristech.fr/sc_simu.html#header">Préambule</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_simu.html#simu">Simulation</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_simu.html#debug">Debug</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_simu.html#makefile">Makefile</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_simu.html#exos">Exercices</a></li>
      <li><a href="http://hdl.telecom-paristech.fr/sc_simu.html#enbref">Résumé</a></li>
    </ul>
  </li>
</ul>
<div class="navbar_icons">
<ul>
  <li><a href="http://hdl.telecom-paristech.fr/index.html" title="Accueil"><img style="border: 0px solid ; width: 15px; height: 13px;" alt="Accueil" src="./Premiers exemples_files/up.png"></a></li>
</ul>
</div>
</div>

<div id="intro" class="panneau">
<h3>Introduction</h3>

<h4>Objectifs</h4>

<p>Plutôt que de long discours, voici quelques exemples de
modules écrits en SystemC. Chaque exemple introduit un nouveau type de
construction / type de donnée. </p>

<p>Pour chaque exemple, passez la souris sur le code pour avoir
des explications sur la façon dont il est construit.</p>

<h4>Plan du chapitre </h4>

<ul>

  <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_and3">combinatoire
: AND3</a></li>

  <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_dff">séquentiel
: bascule D (DFF)</a></li>

  <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_dffa">bascule D
avec reset asynchrone (DFFA)</a></li>

  <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_compteur">compteur
8 bits synchrone</a></li>

  <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_shifter">registre
à décalage 8 bits</a></li>

  <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_ram">mémoire
simple port</a></li>

  <li><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#e_simu">environnement
de simulation</a></li>

</ul>

<p>&nbsp;</p>

<div style="text-align: right;"><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#header" title="return to the top of the page">Back
to top</a></div>

</div>

<div id="nav1" class="panneau">
<h3><a name="e_and3"></a>AND3</h3>

<p>Le plus simple des modules ou presque : une porte combinatoire
AND à trois entrées. </p>

<div class="code_commente" id="and3">
<img src="./Premiers exemples_files/sc_and3.png" alt="code and3">
<div class="code_hotspot" id="and3_include">
<div class="code_explain">
<h5>Inclusion des définitions SystemC</h5>

<span class="code">#include "systemc.h"</span>
<blockquote>
  <p> Tous les modules utilisant des classes de SystemC
doivent inclure cette déclaration. </p>

  <p> Il est nécessaire de donner à gcc, lors de la
compilation, le chemin vers les librairies SystemC. Pour les machines
de COMELEC, c'est avec l'option <span class="code">-I/comelec/softs/opt/systemc-2.3.0/include.</span></p>

  <p>Typiquement, ce genre d'option se positionne dans un
Makefile...</p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="and3_scmodule">
<div class="code_explain">
<h5>Déclaration du module</h5>

<span class="code">SC_MODULE(and3)</span>
<blockquote>
  <p>C'est la déclaration du module, effectuée à l'aide d'une
macro SystemC. On lui donne en argument le nom du module.</p>

  <p>Dans la suite du code, on déclare ses variables
internes, ainsi que ses méthodes.<br>

Même s'il vaut mieux séparer déclaration et implémentation, on a ici
tout regroupé dans la déclaration de la classe pour produire un code
plus lisible. </p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="and3_ports">
<div class="code_explain">
<h5>Déclaration des ports </h5>

<blockquote>
  <p>Les macros <span class="code">sc_in</span>,
  <span class="code">sc_out</span> et <span class="code">sc_inout</span> servent à définir des <em>ports</em>
qui seront reliés à des <em>signaux</em> (un type
particulier et très simple de canal).</p>

  <p>Ces macros prennent en argument le <em>type</em>
du signal (booléen, vecteur, logique multivaluée, etc...). </p>

  <p>On définit donc ici quatre ports, 3 en entrée, 1 en
sortie, tous de type booléen (bit).</p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="and3_proc">
<div class="code_explain">
<h5>Déclaration des processus</h5>

<blockquote>
  <p>Un processus est une fonction de type <span class="code">void
f()</span>.</p>

  <p>Ici on déclare la fonction <span class="code">compute_and</span>,
qui réalise le ET logique des 3 ports en entrée, et affecte le résultat
à la sortie du module.</p>

  <p>Pour l'instant, cette fonction est seulement une <em>méthode</em>
du module <span class="code">and3</span>, au même
type que n'importe quelle autre méthode.</p>

  <p>Il faut maintenant déclarer au moteur de simulation :</p>

  <ul>

    <li>que cette méthode est en fait un processus, </li>

    <li>et quelle est sa liste de sensibilité. </li>

  </ul>

  <p>C'est l'objectif de la prochaine instruction. <br>

  </p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="and3_constr">
<div class="code_explain">
<h5>Déclaration du constructeur et des listes de sensibilité
des processus </h5>

<blockquote>
  <p>Chaque classe C++ doit avoir un constructeur, dont le
but est de faire toutes les initialisation de l'objet en question. On
le déclare ici à l'aide de la macro <span class="code">SC_CTOR</span>,
qui prend en argument le nom du module en question. </p>

  <p>Ici, la seule initialisation consiste à déclarer que la
fonction <span class="code">compute_and</span>
n'est pas seulement une fonction pratique, mais un <em>processus</em>
(au sens HDL du terme). C'est fait par la macro <span class="code">SC_METHOD</span>,
qui est l'un des trois types de processus possible (on étudiera les
autres après). </p>

  <p>L'instruction <span class="code">sensitive</span>
sert à préciser la liste de sensibilité du dernier processus déclaré.
Une fonction AND étant combinatoire, on déclare donc le processus <span class="code">compute_and</span> comme étant sensible
aux trois signaux d'entrée, sur chacun de leur front.</p>

  <p><span style="text-decoration: underline;">Remarque</span>
:il existait une notation plus familière, dite "fonctionnelle", <span class="code">sensitive(...)</span>
mais elle est maintenant obsolète. On n'utilise maintenant plus que la
notation dite
"de flot" : <span class="code">sensitive &lt;&lt;
e1;</span> <br>

Si le processus est sensible à plusieurs signaux, on peut même
enchaîner : <span class="code">sensitive
&lt;&lt; e1 &lt;&lt; e2 &lt;&lt; e3;</span>
  </p>

</blockquote>

</div>

</div>

</div>

<div style="text-align: right;"><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#header" title="return to the top of the page">Back
to top</a></div>

</div>

<div id="nav2" class="panneau">
<h3><a name="e_dff"></a>Bascule D simple (DFF)
</h3>

<div class="code_commente" id="dff">
<img src="./Premiers exemples_files/sc_dff.png" alt="code DFF">
<div class="code_hotspot" id="dff_include">
<div class="code_explain">
<h5>Inclusion des définitions SystemC</h5>

<span class="code">#include "systemc.h"</span>
<blockquote>
  <p> Tous les modules utilisant des classes de SystemC
doivent inclure cette déclaration. </p>

  <p> Il est nécessaire de donner à gcc, lors de la
compilation, le chemin vers les librairies SystemC. Pour les machines
de COMELEC, c'est avec l'option <span class="code">-I/comelec/softs/opt/systemc-2.3.0/include.</span></p>

  <p>Typiquement, ce genre d'option se positionne dans un
Makefile...</p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="dff_scmodule">
<div class="code_explain">
<h5>Déclaration du module</h5>

<span class="code">SC_MODULE(dff)</span>
<blockquote>
  <p>Comme dans l'exemple précédent, on déclare le module à
l'aide de la macro <span class="code">SC_MODULE</span>.</p>

  <p>On aurait pu déclarer le module de façon plus classique,
en déclarant une classe héritant de <span class="code">sc_module</span>,
cela sera vu dans un exemple ultérieur. </p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="dff_ports">
<div class="code_explain">
<h5>Déclaration des ports</h5>

<blockquote>
  <p>Une bascule D a deux ports en entrée (<span class="code">din</span>
et <span class="code">clock</span>),
et un port en sortie (<span class="code">dout</span>).</p>

  <p>Ces ports seront connectés à des signaux sur 1 bit. Deux
conséquences : </p>

  <ul>

    <li>les ports seront connectés à des signaux, ils devront
donc être spécialisés pour l'interface propre aux signaux. D'où les
macros de
type générique <span class="code">sc_in</span> et <span class="code">sc_out</span>. <br>

&nbsp;</li>

    <li>les signaux sont sur 1 bit, les deux types génériques
sont donc spécialisés pour le type <span class="code">bool</span>
: <span class="code">sc_in&lt;bool&gt;</span>
et <span class="code">sc_out&lt;bool&gt;</span>
    </li>

  </ul>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="dff_proc">
<div class="code_explain">
<h5>Déclaration des processus</h5>

<blockquote>
  <p>Une bascule D simple n'a qu'un seul processus. </p>

  <p>On définit donc une fonction (<span class="code">echantillonne</span>)
qui se charge de lire le port en entrée <span class="code">din</span>
et d'affecter le port en sortie <span class="code">dout</span>.
  </p>

  <p>Remarque : pour l'instant cette méthode n'est pas un
processus ! </p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="dff_constr">
<div class="code_explain">
<h5>Déclaration du constructeur et des listes de sensibilité
des processus </h5>

<blockquote>
  <p>Comme dans l'exemple précédent, dans le constructeur du
module on enregistre la fonction <span class="code">echantillonne</span>
comme un processus. </p>

  <p>On précise aussi la liste de sensibilité (<span class="code">clock</span>), en ne gardant que les
fronts montants.</p>

</blockquote>

</div>

</div>

</div>

<div style="text-align: right;"><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#header" title="return to the top of the page">Back
to top</a></div>

</div>

<div id="nav3" class="panneau">
<h3><a name="e_dffa"></a>Bascule D avec reset
asynchrone (DFFA) </h3>

<div class="code_commente" id="dffa">
<img src="./Premiers exemples_files/sc_dffa.png" alt="code DFFA">
<div class="code_hotspot" id="dffa_proc">
<div class="code_explain">
<h5>Déclaration des processus</h5>

<blockquote>
  <p>Une bascule D avec reset asynchrone (actif à l'état bas)
a aussi un seul processus, sensible à deux événements :</p>

  <ul>

    <li>le front montant de l'horloge</li>

    <li>l'état du reset.</li>

  </ul>

  <p>Dans le corps du processus, selon le type d'événement
qui a déclenché le processus, soit on met la sortie à 0, soit on
échantillonne l'entrée. </p>

  <p>Pour savoir quel signal a déclenché le processus (<span class="code">reset</span> ou <span class="code">clock</span>),
on utilise la méthode <span class="code">.event</span>
du port <span class="code">clock</span>. Cette
méthode renvoie <span class="code">true</span> si
le signal auquel est relié le port a changé.</p>

</blockquote>

</div>

</div>

</div>

<h5>&nbsp;</h5>

<blockquote>
  <p><span style="text-decoration: underline;">Exercice</span>
: donnez la description en SystemC d'une bascule avec reset
actif à l'état bas synchrone.</p>
</blockquote>

<a class="toggle_answer">Afficher la réponse</a>

<div class="answer" style="border: 1px dotted red; padding: 0.5em; display: none;">
<p><strong>Réponse : </strong></p>

<blockquote>
  <h5>Dff avec reset synchrone </h5>

  <pre class="verbatim">#include "systemc.h"<br>SC_MODULE(dffs)<br>{<br> sc_in&lt;bool&gt; clock;<br> sc_in&lt;bool&gt; reset;<br> sc_in&lt;bool&gt; din;<br> sc_out&lt;bool&gt; dout;<br><br> void do_bascule()<br> {<br> if (!reset) {<br> dout = false;<br> } else {<br> dout = din;<br> }<br> };<br><br> SC_CTOR(dffs)<br> {<br> SC_METHOD(do_bascule);<br> sensitive &lt;&lt; clock.pos();<br> }<br>};<br></pre>

  <p>&nbsp; </p>

</blockquote>

</div>

<div style="text-align: right;"><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#header" title="return to the top of the page">Back
to top</a></div>

</div>

<div id="nav4" class="panneau">
<h3><a name="e_compteur"></a>Compteur 8 bits
synchrone </h3>

<div class="code_commente" id="compt">
<img src="./Premiers exemples_files/sc_compteur.png" alt="code compteur">
<div class="code_hotspot" id="compt_ports">
<div class="code_explain">
<h5>Déclaration des ports</h5>

<blockquote>
  <p>On implémente ici un compteur avec reset synchrone. Il a
trois ports :</p>

  <ul>

    <li><span class="code">clock</span> :
entrée, signal sur 1 bit</li>

    <li><span class="code">reset</span> :
entrée, signal sur 1 bit</li>

    <li><span class="code">out</span>
(valeur du compteur) : sortie, signal entier sur 8 bits.</li>

  </ul>

  <p> <br>

On pourrait utiliser beaucoup de type pour la sortie <span class="code">out</span> : </p>

  <ul>

    <li>les types les plus rapides étant les types natifs
C++, un <span class="code">unsigned char</span>
aurait très bien convenu. Mais il aurait alors fallu gérer à la main le
débordement (passage de 255 à 0).<br>

&nbsp; </li>

    <li>SystemC propose des vecteurs de bits, comme <span class="code">sc_bc</span> ou <span class="code">sc_lv</span>.
Mais il n'y a pas d'opérateur d'addition de prévu pour ces types (pour
un compteur, c'est gênant...). On utilise donc le type <span class="code">sc_uint&lt;n&gt;,</span> qui est
un entier non signé sur n bits. </li>

  </ul>

  <p><br>

  <span style="text-decoration: underline;">Remarque
importante</span> : l'espace entre
les deux crochets fermant est nécessaire en C++, sinon ça ne compile
pas ! </p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="compt_proc">
<div class="code_explain">
<h5>Processus de comptage </h5>

<blockquote>
  <p>A chaque front montant de l'horloge, si <span class="code">reset</span> est bas, on remet le
compteur à 0, sinon on l'incrémente. Tout le travail est fait sur la
variable d'état interne <span class="code">value</span>.</p>

  <p>Comme value est de type <span class="code">sc_uint&lt;&gt;,</span>
on peut utiliser les même opérateurs arithmétiques que ceux définit
pour les entiers. </p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="compt_var">
<div class="code_explain">
<h5>Déclaration d'une variable interne</h5>

<blockquote>
  <p>Pour maintenir l'état du compteur, on utilise une
variable interne, <span class="code">value</span>.
On aurait pu lui donner le type <span class="code">unsigned
char</span>, sur 8 bits aussi. La simulation aurait été plus
rapide. Mais pour rester cohérent, nous prenons le même type que le
signal externe, soit <span class="code">sc_uint&lt;8&gt;</span>.</p>

  <p>L'utilisation d'une variable interne n'est pas
obligatoire. On aurait pu, à chaque front montant d'horloge, aller lire
  <span class="code">out</span>, l'incrémenter,
et ressortir la nouvelle valeur. Mais <span class="code">out</span>
est définie en type <span class="code">sc_out</span>,
qui ne peut pas être lu (<span class="code">sc_out</span>
n'implémente pas la méthode <span class="code">read()</span>,
autrement dit on ne peut pas écrire <span class="code">truc
= out;</span> ). Il aurait alors fallu définir <span class="code">out</span> de type <span class="code">sc_inout</span>,
ce qui est conceptuellement gênant, <span class="code">out</span>
étant une sortie. Ce genre de situation (où les sorties ne peuvent pas
être lues) arrive aussi en VHDL, mais pas en Verilog. </p>

</blockquote>

</div>

</div>

</div>

<p>&nbsp;</p>

<blockquote>
  <p><span style="text-decoration: underline;">Exercice</span>
: modifiez le compteur pour lui ajouter une entrée <span class="code">load</span> sur 1 bit, une entrée <span class="code">in</span> sur 8 bits (si <span class="code">load</span> est haut, le compteur doit
être pré-chargé avec la valeur <span class="code">in</span>),
et modifiez le type de la variable interne <span class="code">value</span>
pour utiliser un <span class="code">unsigned char</span>.
  </p>

  <p>Est-ce qu'il compile correctement ? <em style="text-decoration: underline;">Vérifiez
!</em> <br>

Pour information, la ligne de commande pour la compilation sur les
stations Linux du département est : </p>

  <pre class="code"> g++ -Wno-deprecated -I/comelec/softs/opt/systemc-2.3.0/include -c compt.cpp</pre>

</blockquote>

<a class="toggle_answer">Afficher la réponse</a>


<div class="answer" style="border: 1px dotted red; padding: 0.5em; position: relative; display: none;">
<p><strong>Réponse : </strong></p>

<blockquote>
  <div id="compt_load"></div>

  <div id="compt_load_expl">
  <h5>Problème de la lecture des ports </h5>

  <blockquote>
    <p>Si vous avez écrit une ligne du style <span class="code">value = in</span>, votre modèle ne
compile pas correctement : </p>

    <ul>

      <li><span class="code">value</span> est
de type <span class="code">unsigned char</span></li>

      <li><span class="code">in</span> est de
type <span class="code">sc_in&lt;sc_uint&lt;8&gt;
&gt;</span></li>

      <li>il y aurait donc deux transtypages implicites, le
premier de <span class="code">sc_in</span> vers <span class="code">sc_uint&lt;8&gt;,</span> le
second de <span class="code">sc_uint&lt;8&gt;</span>
vers <span class="code">unsigned char</span>, ce
qui est interdit en C++ (un seul transtypage à la fois). </li>

    </ul>

    <p>Il faut alors utiliser la fonction explicite de lecture <span class="code">in.read()</span> qui renvoie la valeur du
signal associé au port (<span class="code">sc_uint&lt;8&gt;</span>).
Le transtypage peut alors être effectué. </p>

  </blockquote>

  </div>

</blockquote>

</div>

<div style="text-align: right;"><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#header" title="return to the top of the page">Back
to top</a></div>

</div>

<div id="nav5" class="panneau">
<h3><a name="e_shifter"></a>Registre à
décalage 8 bits</h3>

<blockquote>
  <p>Cet exemple est séparé en deux fichiers, le premier (<span class="code">shift.h)</span> contient les
déclarations, le deuxième (<span class="code">shift.cpp</span>)
contient l'implémentation. </p>

</blockquote>

<div class="code_commente" id="shifter">
<img src="./Premiers exemples_files/sc_shift.png" alt="code shifter">
<div class="code_hotspot" id="shifter_constr">
<div class="code_explain">
<h5>Constructeur</h5>

<blockquote>
  <p>Nous avons choisi ici de déclarer le constructeur du
module de la façon habituelle en C++, c'est-à-dire sans utiliser la
macro <span class="code">SC_CTOR</span>. </p>

  <p>Le constructeur prend alors en argument le nom du
module, qui servira lors du debug, et passe ce nom au constructeur de la
classe de base (<span class="code">sc_module</span>).</p>

  <p>Remarque : on ne doit pas préciser le
type de renvoi du constructeur, même pas <span class="code">void</span>...</p>

  <p>La macro <span class="code">SC_CTOR</span>
n'étant pas utilisée, on doit utiliser la macro <span class="code">SC_HAS_PROCESS</span>
pour spécifier que ce module a un processus.</p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="shifter_sigs">
<div class="code_explain">
<h5>Variables et signaux </h5>

<blockquote>
  <p>Dans l'en-tête du module, on déclare un tableau de
variables internes <span class="code">regs</span>
qui serviront à implémenter le décalage. </p>

  <p>Ils sont de type <span class="code">sc_signal</span>,
ce sont donc des signaux : les affectations à des signaux sont
différées, ce qui permet d'effectuer les affectations (méthode <span class="code">shifter::shift</span>) dans n'importe
quel ordre.</p>

  <p>Si on les avait défini de type <span class="code">bool</span>,
la simulation aurait été plus rapide, mais les affectations auraient
alors été immédiates : il aurait fallu faire attention à leur
ordre.&nbsp;</p>

  <p>On aurait pu aussi utiliser les types vecteurs de bits
de SystemC <span class="code">sc_bv&lt;8&gt;</span>,
qui sont particulièrement adaptés
aux manipulations de bits. On aurait alors eu le code suivant :</p>

  <blockquote class="code">
    <p> sc_bv&lt;8&gt; regs;</p>

    <p>...</p>

    <p>regs.range(1,7) = regs.range(0,6);<br>

regs[0] = din; <br>

dout = regs[7]; </p>

  </blockquote>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="shifter_constr2">
<div class="code_explain">
<h5>Constructeur</h5>

<blockquote>
  <p>Nous avons choisi ici de déclarer le constructeur du
module de la façon habituelle en C++, c'est-à-dire sans utiliser la
macro <span class="code">SC_CTOR</span>. </p>

  <p>Le constructeur prend alors en argument le nom du
module, qui servira lors de la génération des chronogrammes, et passe
ce nom au constructeur de la classe de base (<span class="code">sc_module</span>).</p>

  <p>Remarque : on ne doit pas préciser le
type de renvoi du constructeur, même pas <span class="code">void</span>...</p>

  <p>La macro <span class="code">SC_CTOR</span>
n'étant pas utilisée, on doit utiliser la macro <span class="code">SC_HAS_PROCESS</span>
pour spécifier que ce module a un processus. <br>

  </p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="shifter_sigs2">
<div class="code_explain">
<h5>Variables et signaux </h5>

<blockquote>
  <p>Dans l'en-tête du module, on déclare un tableau de
variables internes <span class="code">regs</span>
qui serviront à implémenter le décalage. </p>

  <p>Ils sont de type <span class="code">sc_signal</span>,
ce sont donc des signaux : les affectations à des signaux sont
différées, ce qui permet d'effectuer les affectations (méthode <span class="code">shifter::shift</span>) dans n'importe
quel ordre.</p>

  <p>Si on les avait défini de type <span class="code">bool</span>,
la simulation aurait été plus rapide, mais les affectations auraient
alors été immédiates : il aurait fallu faire attention à leur ordre. </p>

  <p>On aurait pu aussi utiliser les types vecteurs de bits
de SystemC <span class="code">sc_bv&lt;8&gt;</span>,
qui sont particulièrement adaptés
aux manipulations de bits. On aurait alors eu le code suivant :</p>

  <blockquote class="code">
    <p> sc_bv&lt;8&gt; regs;</p>

    <p>...</p>

    <p>regs.range(1,7) = regs.range(0,6);<br>

regs[0] = din; <br>

dout = regs[7]; </p>

  </blockquote>

</blockquote>

</div>

</div>

</div>

<div style="text-align: right;"><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#header" title="return to the top of the page">Back
to top</a></div>

</div>

<div id="nav6" class="panneau">
<h3><a name="e_ram"></a>Mémoire simple port</h3>

<p>...ou comment gérer des bus 3 états (et des tableaux). Cet
exemple modélise un chip de SRAM asynchrone, possédant : </p>

<ul>

  <li>un bus d'adresse sur 8 bits : <span class="code">addr</span>
  </li>

  <li>un bus de données bidirectionnel sur 16 bits : <span class="code">data</span> </li>

  <li>un signal d'output enable (actif à l'état bas) : <span class="code">oen</span> </li>

  <li>un signal de write (actif à l'état bas) : <span class="code">wen</span> </li>

</ul>

<p>La direction du bus, du point de vue de la RAM, est donnée par
<span class="code">oen</span> : <span class="code">oen</span> actif (bas) rend la RAM maître
du bus de données. <br>

L'écriture est effectuée si <span class="code">wen</span>
est actif (bas) et que le bus de données est en entrée (<span class="code">oen</span> inactif/haut).</p>

<div class="code_commente" id="ram">
<img src="./Premiers exemples_files/sc_ram.png" alt="code RAM">
<div class="code_hotspot" id="ram_ports">
<div class="code_explain">
<h5>Ports</h5>

<blockquote>
  <p>Le bus de données de la RAM est bidirectionnel, il est
donc déclaré en <span class="code">inout</span>.</p>

  <p> De plus, plusieurs RAM peuvent être branchées en
parallèle. Des conflits peuvent donc potentiellement arriver si
plusieurs RAM mettent des valeurs différentes sur le bus de données. Le
port doit donc résoudre les conflits. On utilise pour cela le type <span class="code">sc_inout_rv&lt;&gt;</span>. </p>

  <p>Pour un driver 3-états en sortie seulement, on aurait
utilisé le type <span class="code">sc_out_rv&lt;&gt;</span>.<br>

Pour un port en entrée, on aurait utilisé <span class="code">sc_in_rv&lt;&gt;</span>.
  </p>

  <p>Les ports résolus ne doivent être utilisés que là où
c'est nécessaire, car ils simulent plus lentement que les types non
résolus.</p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="ram_vars">
<div class="code_explain">
<h5> Variable interne</h5>

<blockquote>
  <p>Le contenu de la RAM est stocké dans un tableau de 256
valeurs (car le bus d'adresse est sur 8 bits).</p>

  <p>Pour détecter les lectures de RAM à des adresses non
initialisées on utilise un type de logique 4-valuée. Ainsi si on lit la
RAM à une adresse à laquelle on n'a encore rien écrit, on verra sortir
la valeur '<span class="code">X</span>'. SystemC
propose plusieurs types de données 4-valuées :</p>

  <ul>

    <li><span class="code">sc_logic</span>
: sur 1bit</li>

    <li><span class="code">sc_lv&lt;n&gt;</span>
: sur n bits</li>

  </ul>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="ram_procs">
<div class="code_explain">
<h5>Déclaration des processus</h5>

<blockquote>
  <p>Le comportement de la RAM est décrit par deux processus,
un pour l'écriture (mise à jour du tableau interne), l'autre pour la
lecture (mise à jour du bus de données à partir du tableau interne). On
aurait très bien pu écrire la RAM avec un seul processus, mais il est
intéressant ici d'avoir deux processus accédant à la même ressource
(bus <span class="code">data</span>) en même temps.
  </p>

  <p>La RAM est asynchrone, les processus de lecture et
d'écriture sont donc combinatoires. Leur liste de sensibilité est ici
définie par les opérateurs de flot ( <span class="code">&lt;&lt;</span>
).</p>

  <p>On aurait pu aussi utiliser le constructeur pour faire
l'initialisation de la RAM à partir d'un fichier. Typiquement, le nom
du fichier aurait été transmis au constructeur du module. On n'aurait
alors pas pu utiliser la macro <span class="code">SC_CTOR</span>
(qui n'admet pas plus d'argument
que le nom du module), il aurait fallu passer par la déclaration
explicite du constructeur, comme vu dans l'exemple précédent.</p>

  <p>Un exemple de l'intérêt de SystemC :
si la RAM est destinée à stocker des images provenant d'une séquence
vidéo, on aurait pu l'initialiser directement à partir d'un fichier PNG
ou MPEG, en utilisant l'une des bibliothèques C déjà disponibles pour
cela (<span class="appli">libpng</span>, <span class="appli">libmpeg</span>, <span class="appli">libmpeg2</span>,
...). Pas besoin d'écrire ses propres routines de parsing MPEG ou
PNG... </p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="ram_procs2">
<div class="code_explain">
<h5>Implémentation des processus</h5>

<blockquote>
  <p>Le tableau est indexé par les adresses qui sont de type <span class="code">sc_in&lt;sc_int&lt;8&gt; &gt;</span>.
Comme vu précédemment, on est obligé d'utiliser la fonction explicite de
lecture <span class="code">.read()</span> au lieu
d'un simple "<span class="code">=</span>" .</p>

  <p>Cela vient du fait que C++ n'autorise qu'un seul
transtypage implicite, et qu'avec un "<span class="code">=</span>"
il y en aurait deux :</p>

  <ul>

    <li> transtypage du signal associé au port en la valeur
qu'il transporte : <span class="code">sc_signal&lt;sc_int&lt;8&gt;
&gt;</span> vers <span class="code">sc_int&lt;8&gt;</span></li>

    <li>transtypage de <span class="code">sc_int&lt;8&gt;</span>
vers <span class="code">int</span>, car le tableau
de valeurs est indexé par des entiers (<span class="code">int</span>).
    </li>

  </ul>

  <p>On doit donc utiliser la fonction <span class="code">.read()</span>
qui renvoie la valeur du signal (<span class="code">sc_int&lt;8&gt;</span>)
qui peut alors être implicitement être transtypée vers <span class="code">int</span>. </p>

  <p>La plupart des synthétiseurs SystemC demandent à ce les
accès aux signaux se fassent explicitement par les méthodes <span class="code">.read()</span> et <span class="code">.write()</span>,
et de réserver les affectations directes "<span class="code">=</span>"
aux variables.<br>

Cela rend le code un peu plus verbeux, mais plus clair. </p>

  <p>Enfin, l'affectation d'une valeur littérale à un vecteur
de bits se fait par une chaîne de caractères. <br>

Exemple : <span class="code">data
= "11100ZX01ZXX0XZ0";</span> </p>

  <h5><br>

  </h5>

</blockquote>

</div>

</div>

</div>

<div style="text-align: right;"><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#header" title="return to the top of the page">Back
to top</a></div>

</div>

<div id="nav7" class="panneau">
<h3><a name="e_simu"></a>L'environnement de
simulation </h3>

<h4>Introduction</h4>

<p>Le sujet des environnements de simulation est vaste et sera
envisagé dans le dernier chapitre. Nous vous présentons ici un
environnement très simple, qui vous permettra de tester les modules
ci-dessus. </p>

<p>L'exemple ci-dessous instancie le registre à décalage vu <a href="http://hdl.telecom-paristech.fr/sc_exemples.html#shifter">plus haut</a>, lui fournit une horloge
et
quelques vecteurs d'entrée. Il ne vérifie pas la sortie, il se contente
de tracer certains signaux, laissant au concepteur le soin de visionner
les chronogrammes et de vérifier qu'ils sont corrects. Bien entendu, un
système réel ne serait pas testé de cette façon !</p>

<p>Cet exemple vous montre :</p>

<ul>

  <li>comment instancier un module</li>

  <li>comment instancier des signaux, et les relier aux ports du
module</li>

  <li>comment gérer le déroulement de la simulation, et produire
des vecteurs de test.</li>

</ul>

<p>&nbsp;</p>

<h4>Manipulation</h4>

<p>Il se compose de trois fichiers : <span class="code">shift.h</span>,
<span class="code">shift.cpp</span> et <span class="code">test_shift.cpp</span> (le fichier de test
proprement dit). Vous pouvez récupérer l'<a href="http://hdl.telecom-paristech.fr/sc_docs/test_shift.tgz">archive complète ici</a>.
<br>

Il produit un fichier de chronogrammes, <span class="code">shift_trace.vcd</span>
qui peut être visionné à l'aide de <span class="appli">gtkwave</span>
ou <span class="appli">Modelsim</span>.</p>

<p>Mettez d'abord en place une variable d'environnement SYSTEMC
qui indique où se trouve la bibliothèque : <span class="code">export
SYSTEMC=/comelec/softs/opt/systemc-2.3.0</span></p>

<p>L'exemple est suffisament simple pour se passer de Makefile.
La ligne de compilation :</p>

<blockquote>
  <p class="code">g++ -Wno-deprecated -L$SYSTEMC/lib-linux64
-I$SYSTEMC/include test_shift.cpp shift.cpp -lsystemc -o test_shift </p>

</blockquote>

<p>Une compilation séparée aurait été faite ainsi :</p>

<ul>

  <li> <span class="code">g++ -Wno-deprecated
-I$SYSTEMC/include -c shift.cpp</span></li>

  <li><span class="code">g++ -Wno-deprecated
-I$SYSTEMC/include -c test_shift.cpp</span></li>

  <li><span class="code">g++ -Wno-deprecated
-L$SYSTEMC/lib-linux64 test_shift.o shift.o -lsystemc -o test_shift</span>
(l'éditeur de lien C++ est <span class="appli">g++</span>,
    <span class="appli">ld</span> est réservé au C) </li>

</ul>

<p>&nbsp;</p>

<p>Le <span class="code">Makefile</span>
fourni avec l'archive fait exactement la même chose. Pour l'utiliser :
taper&nbsp;<span class="code">make</span>.</p>

<p>La compilation a généré un exécutable contenant le moteur de
simulation. Il reste à lancer la simulation proprement dite : </p>

<ul>

  <li><span class="code">./test_shift</span></li>

</ul>

<p>&nbsp;</p>

<p><span style="text-decoration: underline;">Exercice</span>
: </p>

<ol>

  <li>les chronogrammes sont-ils corrects ?</li>

</ol>

<h4>Explication</h4>

<div class="code_commente" id="tbench">
<img src="./Premiers exemples_files/sc_test_shift.png" alt="code testbench">
<div class="code_hotspot" id="tbench_main">
<div class="code_explain">
<h5>main et sc_main</h5>

<blockquote>
  <p>La fonction <span class="code">main()</span>
est déjà définie par la bibliothèque SystemC. Elle appelle la fonction <span class="code">sc_main</span>, fournie par
l'utilisateur, qui est le point d'entrée du code utilisateur.</p>

  <p><span class="code">sc_main</span> a
le même prototype que <span class="code">main</span>
: <span class="code">int sc_main(int argc, char *argv[]);</span></p>

  <p>Cette fonction a pour rôle d'instancier tous les modules
et signaux nécessaires, et de lancer la simulation.</p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="tbench_decls">
<div class="code_explain">
<h5>Déclaration des signaux </h5>

<blockquote>
  <p>Le registre à décalage possède trois ports, trois
signaux sont donc nécessaires à son test.<br>

On instancie donc trois signaux, de type <span class="code">bool</span>
(1 bit, en logique 2 valuée).</p>

  <p>L'horloge a aussi un type <span class="code">sc_signal&lt;bool&gt;</span>.
C'est nous qui nous chargerons de la faire bouger.<br>

Il existe en SystemC une façon plus propre de générer des horloges, en
passant par le type <span class="code">sc_clock</span>.<br>

C'est le moteur SystemC qui se charge alors de générer les transitions
des objets <span class="code">sc_clock</span>. </p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="tbench_trace">
<div class="code_explain">
<h5>Trace des signaux </h5>

<blockquote>
  <p>SystemC dispose de fonction de traçage de signaux au format
&nbsp;VCD (Value Change Dump, visible par gtkwave, ... ).</p>

  <p>SystemC permet de tracer les variables scalaires, les
vecteurs de bits, les signaux et certains ports. Pour les objets ne
disposant pas de fonctions de traçage (structures, objets, ...) il est
toujours possible de définir ses propres fonctions de traçage, qui
consistent généralement à tracer les membres de l'objet. Seuls les
objets existant pendant toute la simulation peuvent être tracés. En
d'autres termes, les variables locales ne sont pas traçables. </p>

  <p>Avant de tracer un objet, il faut ouvrir un fichier de
traces. C'est le but de la fonction <span class="code">sc_create_vcd_trace_file()</span>.<br>

Puis on enregistre tous les objets à tracer à l'aide la fonction <span class="code">sc_trace</span>, prenant en argument une
référence ou un pointeur vers l'objet à tracer et un nom associé qui
sera utilisé dans la génération des chronogrammes. </p>

  <p>Il est impératif, sous peine de crash, de fermer le
fichier de trace avant de retourner de <span class="code">sc_main()</span>.</p>

  <p>Plusieurs fichiers de traces peuvent être générés en
même temps, et un même signal peut être tracé dans plusieurs fichiers à
la fois.</p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="tbench_inst">
<div class="code_explain">
<h5>Instanciation et connexion du module à tester</h5>

<blockquote>
  <p>L'instanciation d'un module se fait comme
l'instanciation de n'importe quel objet C++. <br>

On peut le créer de façon statique comme ici (il prend comme argument
celui attendu par son constructeur, c'est-à-dire un nom), ou de façon
dynamique à l'aide de <span class="code">new</span>
(<span class="code">new</span> est l'équivalent de <span class="code">malloc</span> en C++, il permet d'allouer
dynamiquement un objet en passant des arguments à son constructeur).</p>

  <p>La connexion est faite ici de façon explicite : chaque
port et relié explicitement à un signal : <span class="code">shifter.din(in);</span><br>

Il est aussi possible, comme en Verilog ou VHDL, d'utiliser une
connexion par position (implicite).</p>

</blockquote>

</div>

</div>

<div class="code_hotspot" id="tbench_simu">
<div class="code_explain">
<h5>Lancement de la simulation </h5>

<blockquote>
  <p>Une simulation se lance généralement par <span class="code">sc_start</span>, et s'arrête par <span class="code">sc_stop</span>. Comme aucun signal n'est
géré automatiquement dans ce système-ci (pas de <span class="code">sc_clock</span>),
il faut gérer la simulation manuellement.</p>

  <p>La simulation peut être initialisée par l'appel de la
fonction <span class="code">sc_start(SC_ZERO_TIME)</span>,
qui se charge alors de faire toutes les initialisations du scheduler
SystemC, et d'exécuter une fois tous les processus qui ne sont pas
marqués <span class="code">dont_initialize()</span>.
  <br>

Mais
cet appel n'est pas obligatoire : il est fait automatiquement
pas le scheduler lors du lancement de la simulation s'il n'a pas déjà
été fait.</p>

  <p>Remarque : le fonction <span class="code">sc_initialize()</span>
est obsolète, et remplacée par <span class="code">sc_start(SC_ZERO_TIME)</span>.
  </p>

  <p>Les signaux sont alors positionnés à la main, par une
simple affectation (<span class="code">in = 0</span>).
  </p>

  <p>Puis le temps est avancé manuellement par la fonction qu'on
a appelée <span class="code">next_cycle()</span>,
dont le code se trouve en bas du listing : cette fonction positionne
manuellement la ligne d'horloge, et fait à chaque fois avancer la
simulation d'une unité de temps (1ns) grâce à la fonction <span class="code">sc_start()</span>.</p>

</blockquote>

</div>

</div>

</div>

<p><span style="text-decoration: underline;"></span></p>

<p><span style="text-decoration: underline;">Exercice</span>
: </p>

<ol>

  <li>Écrivez le modèle d'une mémoire semblable à&nbsp;<a href="http://hdl.telecom-paristech.fr/sc_exemples.html#ram">celle vue précédemment</a> mais <em>synchrone, </em>et possédant deux bus séparés de données (un pour la lecture, l'autre pour l'écriture).&nbsp;<br>
Écrivez aussi un environnement de test (testbench) rapide pour cette RAM.</li>
  <li>Écrivez les modèles des composants suivants :</li>
</ol>
<ul>
  <ul>
    <li>compteur synchrone (avec horloge) sur 8 bits modulo 127</li>
    <li>dispositif sortant à chaque coup d'horloge les multiples de 2 et 3 dans l'ordre croissant (2, 3, 4, 6, 9, 10, 12, ...)</li>
  </ul>
</ul>

N'oubliez pas de mettre votre code sur le dépôt.<br>
Pensez à 'indenter (xemacs, indent, ...) et commenter votre code de façon à ce qu'il soit
lisible : un code non indenté&nbsp;ne sera pas lu, et donc non corrigé :)<br>
<br>
 
<ol>

</ol>

<p><br>

</p>

<p></p>

<div style="text-align: right;"><a href="http://hdl.telecom-paristech.fr/sc_exemples.html#header" title="return to the top of the page">Back to top</a></div>

</div>

<div id="resume" class="panneau">
<div class="cadre_rouge">
<h3><a name="enbref"></a>En résumé</h3>

<blockquote>
  <p>Vous avez vu ici quelques exemples de modules en SystemC, et
comment instancier un module et lui fournir rapidement quelques
vecteurs de test.</p>

  <p>L'objectif des prochains chapitres est d'étudier plus
précisément les différents types de données disponibles, la façon de
décrire structurellement un système (module, signaux, ports), puis
fonctionnellement (processus, événements).&nbsp;</p>

</blockquote>

</div>

<div style="text-align: right;"><br>

<a href="http://hdl.telecom-paristech.fr/sc_exemples.html#header" title="return to the top of the page">Back
to top</a></div>

</div>

<div id="footer">
<ul id="botNav">

  <li><a href="http://hdl.telecom-paristech.fr/sc_intro.html" title="Chapitre précédent"><img style="border: 0px solid ; width: 14px; height: 13px;" alt="Prev" src="./Premiers exemples_files/previous.png"></a></li>

  <li><a href="http://hdl.telecom-paristech.fr/sc_intro.html" title="Menu général"><img style="border: 0px solid ; width: 15px; height: 13px;" alt="Up" src="./Premiers exemples_files/up.png"></a></li>

  <li><a href="http://hdl.telecom-paristech.fr/sc_datatypes.html" title="Chapitre suivant"><img style="border: 0px solid ; width: 14px; height: 13px;" alt="Next" src="./Premiers exemples_files/next.png"></a></li>

</ul>

<p>© Alexis Polti, COMELEC 2005-2014</p>

</div>



</body></html>